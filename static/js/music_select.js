// Load the file randomizer/Enums/Songs.jsonc so we can store it as the Song enum.
// This file is generated by the build process.
let Songs = null;
// TODO: THIS LIST SHOULD BE GENERATED OUT OF THE SONGS FILE
var SongLocationList = [
  "TrainingGrounds",
  "Isles",
  "IslesKremIsle",
  "IslesKLumsy",
  "IslesBFI",
  "IslesSnideRoom",
  "JapesLobby",
  "AztecLobby",
  "FactoryLobby",
  "GalleonLobby",
  "ForestLobby",
  "CavesLobby",
  "CastleLobby",
  "HelmLobby",
  "JapesMain",
  "JapesStart",
  "JapesTunnels",
  "JapesStorm",
  "JapesCaves",
  "JapesBlast",
  "JapesCart",
  "JapesDillo",
  "AztecMain",
  "AztecTunnels",
  "AztecTemple",
  "Aztec5DT",
  "AztecBlast",
  "AztecBeetle",
  "AztecChunkyKlaptraps",
  "AztecDogadon",
  "FactoryMain",
  "FactoryProduction",
  "FactoryResearchAndDevelopment",
  "FactoryCrusher",
  "FactoryCarRace",
  "FactoryJack",
  "GalleonTunnels",
  "GalleonOutside",
  "GalleonLighthouse",
  "GalleonMechFish",
  "Galleon2DS",
  "Galleon5DS",
  "GalleonMermaid",
  "GalleonChest",
  "GalleonBlast",
  "GalleonSealRace",
  "GalleonPufftoss",
  "ForestDay",
  "ForestNight",
  "ForestBarn",
  "ForestMill",
  "ForestAnthill",
  "ForestMushroom",
  "ForestMushroomRooms",
  "ForestSpider",
  "ForestBlast",
  "ForestRabbitRace",
  "ForestCart",
  "ForestDogadon",
  "Caves",
  "CavesIgloos",
  "CavesCabins",
  "CavesRotatingRoom",
  "CavesTantrum",
  "CavesBlast",
  "CavesIceCastle",
  "CavesBeetleRace",
  "CavesDillo",
  "Castle",
  "CastleShed",
  "CastleTree",
  "CastleTunnels",
  "CastleCrypt",
  "CastleInnerCrypts",
  "CastleDungeon_Chains",
  "CastleDungeon_NoChains",
  "CastleBallroom",
  "CastleMuseum",
  "CastleGreenhouse",
  "CastleTrash",
  "CastleTower",
  "CastleBlast",
  "CastleCart",
  "CastleKutOut",
  "HelmBoMOn",
  "HelmBoMOff",
  "HelmBonus",
  "Cranky",
  "Funky",
  "Candy",
  "Snide",
  "WrinklyKong",
  "StrongKong",
  "Rocketbarrel",
  "Sprint",
  "MiniMonkey",
  "HunkyChunky",
  "GorillaGone",
  "Rambi",
  "Enguarde",
  "BattleArena",
  "TroffNScoff",
  "AwaitingBossEntry",
  "BossIntroduction",
  "MiniBoss",
  "KRoolBattle",
  "MainMenu",
  "PauseMenu",
  "NintendoLogo",
  "IntroStory",
  "KRoolTheme",
  "KLumsyCelebration",
  "KRoolTakeoff",
  "KRoolEntrance",
  "KLumsyEnding",
  "EndSequence",
  "Minigames",
  "MadMazeMaul",
  "StealthySnoop",
  "MinecartMayhem",
  "OhBanana",
  "GBGet",
  "MoveGet",
  "GunGet",
  "BananaMedalGet",
  "BlueprintDrop",
  "BlueprintGet",
  "HeadphonesGet",
  "DropRainbowCoin",
  "RainbowCoinGet",
  "CompanyCoinGet",
  "BeanGet",
  "PearlGet",
  "MelonSliceDrop",
  "MelonSliceGet",
  "BananaCoinGet",
  "CrystalCoconutGet",
  "FairyTick",
  "MinecartCoinGet",
  "DropCoins",
  "Checkpoint",
  "NormalStar",
  "Success",
  "Failure",
  "SuccessRaces",
  "FailureRaces",
  "BossUnlock",
  "BossDefeat",
  "Bongos",
  "Guitar",
  "Trombone",
  "Saxophone",
  "Triangle",
  "BaboonBalloon",
  "Transformation",
  "VultureRing",
  "BBlastFinalStar",
  "FinalCBGet",
];
var MusicSelectionPanel = {"BGM":{"name":"BGM","subcategories":{"Isles":{"name":"DK Isles","type":"BGM","songs":[{"name":"Training Grounds","value":"TrainingGrounds"},{"name":"DK Isles","value":"Isles"},{"name":"DK Isles (K. Rool's Ship)","value":"IslesKremIsle"},{"name":"DK Isles (K. Lumsy's Prison)","value":"IslesKLumsy"},{"name":"DK Isles (Banana Fairy Island)","value":"IslesBFI"},{"name":"DK Isles (Snide's Room)","value":"IslesSnideRoom"},{"name":"Jungle Japes (Lobby)","value":"JapesLobby"},{"name":"Angry Aztec (Lobby)","value":"AztecLobby"},{"name":"Frantic Factory (Lobby)","value":"FactoryLobby"},{"name":"Gloomy Galleon (Lobby)","value":"GalleonLobby"},{"name":"Fungi Forest (Lobby)","value":"ForestLobby"},{"name":"Crystal Caves (Lobby)","value":"CavesLobby"},{"name":"Creepy Castle (Lobby)","value":"CastleLobby"},{"name":"Hideout Helm (Lobby)","value":"HelmLobby"}]},"Japes":{"name":"Jungle Japes","type":"BGM","songs":[{"name":"Jungle Japes","value":"JapesMain"},{"name":"Jungle Japes (Starting Area)","value":"JapesStart"},{"name":"Jungle Japes (Tunnels)","value":"JapesTunnels"},{"name":"Jungle Japes (Cranky's Area)","value":"JapesStorm"},{"name":"Jungle Japes (Caves/Underground)","value":"JapesCaves"},{"name":"Jungle Japes (Baboon Blast)","value":"JapesBlast"},{"name":"Jungle Japes (Minecart)","value":"JapesCart"},{"name":"Jungle Japes (Army Dillo)","value":"JapesDillo"}]},"Aztec":{"name":"Angry Aztec","type":"BGM","songs":[{"name":"Angry Aztec","value":"AztecMain"},{"name":"Angry Aztec (Tunnels)","value":"AztecTunnels"},{"name":"Angry Aztec (Temple)","value":"AztecTemple"},{"name":"Angry Aztec (5DT)","value":"Aztec5DT"},{"name":"Angry Aztec (Baboon Blast)","value":"AztecBlast"},{"name":"Angry Aztec (Beetle Slide)","value":"AztecBeetle"},{"name":"Angry Aztec (Chunky Klaptraps)","value":"AztecChunkyKlaptraps"},{"name":"Angry Aztec (Dogadon)","value":"AztecDogadon"}]},"Factory":{"name":"Frantic Factory","type":"BGM","songs":[{"name":"Frantic Factory","value":"FactoryMain"},{"name":"Frantic Factory (Production Room)","value":"FactoryProduction"},{"name":"Frantic Factory (R&D)","value":"FactoryResearchAndDevelopment"},{"name":"Frantic Factory (Crusher Room)","value":"FactoryCrusher"},{"name":"Frantic Factory (Car Race)","value":"FactoryCarRace"},{"name":"Frantic Factory (Mad Jack)","value":"FactoryJack"}]},"Galleon":{"name":"Gloomy Galleon","type":"BGM","songs":[{"name":"Gloomy Galleon (Tunnels)","value":"GalleonTunnels"},{"name":"Gloomy Galleon (Outside)","value":"GalleonOutside"},{"name":"Gloomy Galleon (Lighthouse)","value":"GalleonLighthouse"},{"name":"Gloomy Galleon (Mechanical Fish)","value":"GalleonMechFish"},{"name":"Gloomy Galleon (2DS)","value":"Galleon2DS"},{"name":"Gloomy Galleon (5DS/Submarine)","value":"Galleon5DS"},{"name":"Gloomy Galleon (Mermaid Palace)","value":"GalleonMermaid"},{"name":"Gloomy Galleon (Pearls Chest)","value":"GalleonChest"},{"name":"Gloomy Galleon (Baboon Blast)","value":"GalleonBlast"},{"name":"Gloomy Galleon (Seal Race)","value":"GalleonSealRace"},{"name":"Gloomy Galleon (Pufftoss)","value":"GalleonPufftoss"}]},"Forest":{"name":"Fungi Forest","type":"BGM","songs":[{"name":"Fungi Forest (Day)","value":"ForestDay"},{"name":"Fungi Forest (Night)","value":"ForestNight"},{"name":"Fungi Forest (Barn)","value":"ForestBarn"},{"name":"Fungi Forest (Mill)","value":"ForestMill"},{"name":"Fungi Forest (Anthill)","value":"ForestAnthill"},{"name":"Fungi Forest (Giant Mushroom)","value":"ForestMushroom"},{"name":"Fungi Forest (Mushroom Top Rooms)","value":"ForestMushroomRooms"},{"name":"Fungi Forest (Spider)","value":"ForestSpider"},{"name":"Fungi Forest (Baboon Blast)","value":"ForestBlast"},{"name":"Fungi Forest (Rabbit Race)","value":"ForestRabbitRace"},{"name":"Fungi Forest (Minecart)","value":"ForestCart"},{"name":"Fungi Forest (Dogadon)","value":"ForestDogadon"}]},"Caves":{"name":"Crystal Caves","type":"BGM","songs":[{"name":"Crystal Caves","value":"Caves"},{"name":"Crystal Caves (Igloos)","value":"CavesIgloos"},{"name":"Crystal Caves (Cabins)","value":"CavesCabins"},{"name":"Crystal Caves (Rotating Room)","value":"CavesRotatingRoom"},{"name":"Crystal Caves (Giant Kosha Tantrum)","value":"CavesTantrum"},{"name":"Crystal Caves (Baboon Blast)","value":"CavesBlast"},{"name":"Crystal Caves (Tile Flipping)","value":"CavesIceCastle"},{"name":"Crystal Caves (Beetle Race)","value":"CavesBeetleRace"},{"name":"Crystal Caves (Army Dillo)","value":"CavesDillo"}]},"Castle":{"name":"Creepy Castle","type":"BGM","songs":[{"name":"Creepy Castle","value":"Castle"},{"name":"Fungi Forest (Winch)","value":"CastleShed"},{"name":"Creepy Castle (Tree)","value":"CastleTree"},{"name":"Creepy Castle (Tunnels)","value":"CastleTunnels"},{"name":"Creepy Castle (Crypt)","value":"CastleCrypt"},{"name":"Creepy Castle (Inner Crypts)","value":"CastleInnerCrypts"},{"name":"Creepy Castle (Dungeon w/ Chains)","value":"CastleDungeon_Chains"},{"name":"Creepy Castle (Dungeon w/out Chains)","value":"CastleDungeon_NoChains"},{"name":"Creepy Castle (Ballroom)","value":"CastleBallroom"},{"name":"Creepy Castle (Museum)","value":"CastleMuseum"},{"name":"Creepy Castle (Greenhouse)","value":"CastleGreenhouse"},{"name":"Creepy Castle (Trash Can)","value":"CastleTrash"},{"name":"Creepy Castle (Wind Tower)","value":"CastleTower"},{"name":"Creepy Castle (Baboon Blast)","value":"CastleBlast"},{"name":"Creepy Castle (Minecart)","value":"CastleCart"},{"name":"Creepy Castle (King Kut-Out)","value":"CastleKutOut"}]},"Helm":{"name":"Hideout Helm","type":"BGM","songs":[{"name":"Hideout Helm (Blast-O-Matic On)","value":"HelmBoMOn"},{"name":"Hideout Helm (Blast-O-Matic Off)","value":"HelmBoMOff"},{"name":"Hideout Helm (Bonus Barrels)","value":"HelmBonus"}]},"NPC":{"name":"NPCs","type":"BGM","songs":[{"name":"Cranky's Lab","value":"Cranky"},{"name":"Funky's Hut","value":"Funky"},{"name":"Candy's Music Shop","value":"Candy"},{"name":"Snide's HQ","value":"Snide"},{"name":"Wrinkly Kong","value":"WrinklyKong"}]},"Moves":{"name":"Moves and Animals","type":"BGM","songs":[{"name":"Strong Kong","value":"StrongKong"},{"name":"Rocketbarrel Boost","value":"Rocketbarrel"},{"name":"Orangstand Sprint","value":"Sprint"},{"name":"Mini Monkey","value":"MiniMonkey"},{"name":"Hunky Chunky","value":"HunkyChunky"},{"name":"Gorilla Gone","value":"GorillaGone"},{"name":"Rambi","value":"Rambi"},{"name":"Enguarde","value":"Enguarde"}]},"Battle":{"name":"Battles","type":"BGM","songs":[{"name":"Battle Arena","value":"BattleArena"},{"name":"Troff 'n' Scoff","value":"TroffNScoff"},{"name":"Awaiting Entering the Boss","value":"AwaitingBossEntry"},{"name":"Boss Introduction","value":"BossIntroduction"},{"name":"Mini Boss","value":"MiniBoss"},{"name":"K. Rool's Battle","value":"KRoolBattle"}]},"Story":{"name":"Menus and Story","type":"BGM","songs":[{"name":"Main Menu","value":"MainMenu"},{"name":"Pause Menu","value":"PauseMenu"},{"name":"Nintendo Logo","value":"NintendoLogo"},{"name":"Intro Story Medley","value":"IntroStory"},{"name":"K. Rool's Theme","value":"KRoolTheme"},{"name":"K. Lumsy Celebration","value":"KLumsyCelebration"},{"name":"K. Rool Takeoff","value":"KRoolTakeoff"},{"name":"K. Rool's Entrance","value":"KRoolEntrance"},{"name":"K. Lumsy Ending","value":"KLumsyEnding"},{"name":"End Sequence","value":"EndSequence"}]},"Minigame":{"name":"Minigames","type":"BGM","songs":[{"name":"Bonus Minigames","value":"Minigames"},{"name":"Mad Maze Maul","value":"MadMazeMaul"},{"name":"Stealthy Snoop","value":"StealthySnoop"},{"name":"Minecart Mayhem","value":"MinecartMayhem"}]}}},"ItemsEvents":{"name":"Items and Events","subcategories":{"MajorItem":{"name":"Major Items","type":"MajorItem","songs":[{"name":"Oh Banana","value":"OhBanana"},{"name":"Golden Banana/Key Get","value":"GBGet"},{"name":"Move Get","value":"MoveGet"},{"name":"Gun Get","value":"GunGet"},{"name":"Banana Medal Get","value":"BananaMedalGet"},{"name":"Blueprint Drop","value":"BlueprintDrop"},{"name":"Blueprint Get","value":"BlueprintGet"},{"name":"Headphones Get","value":"HeadphonesGet"},{"name":"Drop Rainbow Coin","value":"DropRainbowCoin"},{"name":"Rainbow Coin Get","value":"RainbowCoinGet"},{"name":"Company Coin Get","value":"CompanyCoinGet"},{"name":"Bean Get","value":"BeanGet"},{"name":"Pearl Get","value":"PearlGet"}]},"MinorItem":{"name":"Minor Items","type":"MinorItem","songs":[{"name":"Melon Slice Drop","value":"MelonSliceDrop"},{"name":"Melon Slice Get","value":"MelonSliceGet"},{"name":"Banana Coin Get","value":"BananaCoinGet"},{"name":"Crystal Coconut Get","value":"CrystalCoconutGet"},{"name":"Fairy Tick","value":"FairyTick"},{"name":"Minecart Coin Get","value":"MinecartCoinGet"},{"name":"Drop Coins (Minecart)","value":"DropCoins"},{"name":"Checkpoint","value":"Checkpoint"},{"name":"Normal Star","value":"NormalStar"}]},"Event":{"name":"Events","type":"Event","songs":[{"name":"Success","value":"Success"},{"name":"Failure","value":"Failure"},{"name":"Success (Races)","value":"SuccessRaces"},{"name":"Failure (Races & Try Again)","value":"FailureRaces"},{"name":"Boss Unlock","value":"BossUnlock"},{"name":"Boss Defeat","value":"BossDefeat"},{"name":"Bongo Blast","value":"Bongos"},{"name":"Guitar Gazump","value":"Guitar"},{"name":"Trombone Tremor","value":"Trombone"},{"name":"Saxophone Slam","value":"Saxophone"},{"name":"Triangle Trample","value":"Triangle"},{"name":"Baboon Balloon","value":"BaboonBalloon"},{"name":"Transformation","value":"Transformation"},{"name":"Going through Vulture Ring","value":"VultureRing"},{"name":"Barrel Blast Final Star","value":"BBlastFinalStar"},{"name":"100th CB Get","value":"FinalCBGet"}]}}}}
// Do the fetch using jquery async: false to ensure that the Songs enum is loaded before the rest of the script runs.
// TODO: I'm not loading all the vars I actually need for this yet
$.ajax({
  url: "/randomizer/Enums/Songs.jsonc",
  async: false,
  success: function (data) {
    Songs = JSON.parse(data)["Songs"];
  },
});
// Create an array of music toggle IDs based on the keys of MusicSelectionPanel
let musicToggles = Object.keys(MusicSelectionPanel).map(category => category.replace(" ", ""));

// Add event listeners to the elements based on the musicToggles array
musicToggles.forEach(toggle => {
    document.getElementById(`${toggle}_collapse_toggle`).addEventListener("click", toggle_collapsible_container);
});

function toggle_collapsible_container(evt) {
    /**
     * Show or hide a collapsible container.
     *
     * @param {Event} evt - The click event triggered on the toggle element.
     */
    let targetElement = evt.target;

    if (!targetElement.id.includes("collapse_toggle")) {
        // Get the parent of this element if the ID doesn't contain "collapse_toggle"
        targetElement = targetElement.parentElement;
    }

    let toggledElement = targetElement.id.match(/^(.+)_collapse_toggle$/)[1];

    // Open or close the settings table on the Seed Info tab
    let settingsTable = document.getElementById(toggledElement);
    settingsTable.classList.toggle("collapsed");

    // Toggle the arrow direction (flipped state)
    let toggledArrow = `${toggledElement.replace("_", "-")}-expand-arrow`;
    let settingsArrow = document.getElementsByClassName(toggledArrow).item(0);
    settingsArrow.classList.toggle("flipped");
}

function serialize_music_selections(form, for_file = false) {
  // Serialize music selections into an enum-focused JSON object.

  function get_value(enum_val) {
    // Return either the value of a given enum or the display name.
    return for_file ? enum_val.name : enum_val;
  }

  function is_music_select_input(inputName) {
    // Determine if an input is a song selection input.
    return inputName && inputName.startsWith("music_select_");
  }

  let songs_map = {
    vanilla: {},
    custom: {},
  };

  for (let obj of form) {
    if (!is_music_select_input(obj.name)) {
      continue;
    }

    // Extract the location name using regular expressions.
    let location_name_match = obj.name.match(/^music_select_(.+)$/);
    let location_name = location_name_match ? location_name_match[1] : null;
    if (!location_name) continue;

    let location = get_value(Songs[location_name]);

    if (obj.value !== "") {
      let chosen_song = obj.value;

      // Default values are handled specially.
      if (chosen_song === "default_value") {
        if (for_file) {
          let category = get_music_category(location_name);
          if (is_song_category_randomized(category)) {
            songs_map["vanilla"][location] = get_value(Songs[location_name]);
          }
          continue;
        } else {
          // Assign the appropriate song and continue.
          chosen_song = location_name;
        }
      }

      // If this is an in-game song, use the enum value.
      try {
        songs_map["vanilla"][location] = get_value(Songs[chosen_song]);
      } catch (error) {
        // If this is a custom song, find and use the full string path.
        let bgm_map = zip(cosmetic_truncated_names.bgm, cosmetic_names.bgm);
        let major_map = zip(
          cosmetic_truncated_names.majoritems,
          cosmetic_names.majoritems
        );
        let minor_map = zip(
          cosmetic_truncated_names.minoritems,
          cosmetic_names.minoritems
        );
        let event_map = zip(
          cosmetic_truncated_names.events,
          cosmetic_names.events
        );
        let music_map = [...bgm_map, ...major_map, ...minor_map, ...event_map];

        for (let [truncated_name, path_name] of music_map) {
          if (chosen_song === truncated_name) {
            let final_path_name = path_name;
            if (for_file) {
              final_path_name = get_serialized_custom_path_name(path_name);
            }
            songs_map["custom"][location] = final_path_name;
            break;
          }
        }
      }
    }
  }

  return songs_map;
}

// Utility function to zip two arrays together.
function zip(arr1, arr2) {
  return arr1.map((value, index) => [value, arr2[index]]);
}

function is_song_category_randomized(category) {
  /**
   * Return true if this song category is randomized.
   *
   * @param {string} category - The song category name.
   * @returns {boolean} - True if the song category is randomized.
   */
  let categoryCheckbox = document.getElementById(
    `music_${category}_randomized`
  );
  return categoryCheckbox ? categoryCheckbox.checked : false;
}

function get_music_category(songLocation) {
  /**
   * Return the music category for this song location.
   *
   * @param {string} songLocation - The song location name.
   * @returns {string} - The music category for the song location.
   * @throws {Error} - If the songLocation is invalid.
   */
  let locationSelect = document.getElementById(`music_select_${songLocation}`);
  if (!locationSelect) {
    throw new Error(
      `Value ${songLocation} should not be fed as input to get_music_category.`
    );
  }

  const categories = ["BGM", "MajorItem", "MinorItem", "Event"];
  for (let category of categories) {
    if (locationSelect.classList.contains(`${category}-select`)) {
      return category === "BGM"
        ? category.toLowerCase()
        : `${category.toLowerCase()}s`;
    }
  }

  throw new Error(
    `Value ${songLocation} should not be fed as input to get_music_category.`
  );
}
function reset_music_selections_no_prompt() {
  /**
   * Reset all music selection options to their default settings.
   */
  for (let songLocation of SongLocationList) {
    let songElement = document.getElementById(`music_select_${songLocation}`);
    let category = get_music_category(songLocation);

    if (is_song_category_randomized(category)) {
      songElement.value = "";
    } else {
      songElement.value = "default_value";
    }

    songElement.value = ""; // This line will overwrite the previous line
  }
}
document
  .getElementById("export_music_selections")
  .addEventListener("click", function (evt) {
    /**
     * Save the current music selections to a JSON file.
     */
    let form = $("#form").serializeArray(); // Using jQuery to serialize the form data
    let musicSelectData = serialize_music_selections(form, true);
    download_json_file(musicSelectData, "music_selections.json");
  });

document
  .getElementById("reset_music_selections")
  .addEventListener("click", function (evt) {
    /**
     * Reset all music selection options to their default settings.
     * Issues a prompt first, warning the user.
     */
    if (
      window.confirm("Are you sure you want to reset all music selections?")
    ) {
      reset_music_selections_no_prompt();
      savesettings();
      savemusicsettings();
    }
  });

function is_custom_music_loaded() {
  /**
   * Return true if a custom music pack has been loaded.
   */
  return cosmetic_names !== null;
}

function get_custom_song_map() {
  /**
   * Return a map between song categories and their relevant lists.
   */
  return {
    bgm: zip(cosmetic_names.bgm, cosmetic_truncated_names.bgm),
    majoritems: zip(
      cosmetic_names.majoritems,
      cosmetic_truncated_names.majoritems
    ),
    minoritems: zip(
      cosmetic_names.minoritems,
      cosmetic_truncated_names.minoritems
    ),
    events: zip(cosmetic_names.events, cosmetic_truncated_names.events),
  };
}

function update_custom_path_name(pathName, prefix) {
  /**
   * Replace the prefix of a custom path name with a new prefix.
   *
   * @param {string} pathName - The original path name.
   * @param {string} prefix - The new prefix to replace.
   * @returns {string} - The updated path name.
   */
  return `${prefix}/${pathName.split("/").slice(-2).join("/")}`;
}

function get_serialized_custom_path_name(pathName) {
  /**
   * Obtain a path name for a custom song for writing to file.
   *
   * @param {string} pathName - The original path name.
   * @returns {string} - The serialized path name.
   */
  return pathName.split("/").slice(-2).join("/");
}

function get_current_pack_prefix() {
  /**
   * Get the prefix of the currently loaded music pack, if there is one.
   *
   * This will either return the first time one of our lists is non-empty, or it
   * will return null at the very end. It's a silly way to write a function, but
   * jsProxy objects are hard to work with.
   *
   * @returns {string|null} - The prefix of the currently loaded music pack.
   */
  for (let song of cosmetic_names.bgm) {
    return song.split("/").slice(0, -2).join("/");
  }
  for (let song of cosmetic_names.majoritems) {
    return song.split("/").slice(0, -2).join("/");
  }
  for (let song of cosmetic_names.minoritems) {
    return song.split("/").slice(0, -2).join("/");
  }
  for (let song of cosmetic_names.events) {
    return song.split("/").slice(0, -2).join("/");
  }
  // No custom music has been loaded.
  return null;
}

// Utility function to zip two arrays together.
function zip(arr1, arr2) {
  return arr1.map((value, index) => [value, arr2[index]]);
}
function raise_music_validation_error(errString) {
  /**
   * Raise an error and display a message about an invalid music file.
   *
   * @param {string} errString - The error message to display.
   * @throws {Error} - Throws a JavaScript error with the provided error message.
   */
  let musicErrorsElement = document.getElementById("music_import_errors");
  if (musicErrorsElement) {
    musicErrorsElement.innerText = errString;
    musicErrorsElement.style.display = ""; // Reset the style to display the error message
  }
  throw new Error(errString); // Raises an error in JavaScript
}
function update_custom_song_names(fileContents) {
  /**
   * Update custom music with the name of the newest music zip file.
   *
   * This prevents an issue where the user uploads one music file, saves
   * their selections to file, uploads a music pack with a new name, then
   * tries to import the same file. As long as the songs are in the right
   * place, with the right names, the name of the pack should be irrelevant.
   *
   * @param {Object} fileContents - The contents of the imported file.
   * @returns {Object} - Updated music data with the newest pack prefix.
   */
  let currentPackName = get_current_pack_prefix();
  if (!currentPackName) {
    return fileContents;
  }

  let musicData = {
    vanilla: fileContents["vanilla"],
    custom: {},
  };

  for (let [location, song] of Object.entries(fileContents["custom"])) {
    let pathName = update_custom_path_name(song, currentPackName);
    musicData["custom"][location] = pathName;
  }

  return musicData;
}
function validate_music_location(locationName) {
  /**
   * Ensure that a given location is a valid song location.
   *
   * @param {string} locationName - The location name to validate.
   * @throws {Error} - If the location is invalid.
   */
  try {
    let _ = Songs[locationName];
  } catch (error) {
    let errString = `The music selection file is invalid: "${locationName}" is not a valid song location.`;
    raise_music_validation_error(errString);
  }
}

function validate_custom_song(songPath) {
  /**
   * Ensure that a given song represents a currently loaded custom song.
   *
   * @param {string} songPath - The song path to validate.
   * @throws {Error} - If the custom song is invalid.
   */
  // Check to see if the path is correctly formed.
  let splitPath = songPath.split("/");
  if (splitPath.length !== 2) {
    let errString = `The music selection file is invalid: song name "${songPath}" is malformed.`;
    raise_music_validation_error(errString);
  }

  let [category, songName] = splitPath;

  // Check to see if the path has a valid category.
  if (!["bgm", "majoritems", "minoritems", "events"].includes(category)) {
    let errString = `The music selection file is invalid: song name "${songPath}" has an invalid category "${category}".`;
    raise_music_validation_error(errString);
  }

  // Check to see if any custom music has been loaded.
  if (!is_custom_music_loaded()) {
    let errString = `The music selection file contains custom songs, but no custom songs have been loaded.`;
    raise_music_validation_error(errString);
  }

  // Search for the song in the currently loaded songs.
  let customSongList = get_custom_song_map()[category];
  let songFound = false;
  for (let [loadedSong, _] of customSongList) {
    let loadedSongName = loadedSong.split("/").pop();
    if (songName === loadedSongName) {
      songFound = true;
      break;
    }
  }

  if (!songFound) {
    let errString = `The custom song "${songName}" is not in the currently loaded pack.`;
    raise_music_validation_error(errString);
  }
}

function validate_vanilla_song(songName) {
  /**
   * Ensure that a given song represents a valid song from the base game.
   *
   * @param {string} songName - The song name to validate.
   * @throws {Error} - If the song is invalid.
   */
  try {
    let _ = Songs[songName];
  } catch (error) {
    let errString = `The music selection file is invalid: "${songName}" is not a valid song name.`;
    raise_music_validation_error(errString);
  }
}
